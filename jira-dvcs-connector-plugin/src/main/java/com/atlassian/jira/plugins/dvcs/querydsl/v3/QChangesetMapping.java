package com.atlassian.jira.plugins.dvcs.querydsl.v3;

import com.atlassian.pocketknife.api.querydsl.SchemaProvider;
import com.mysema.query.sql.ColumnMetadata;
import com.mysema.query.sql.RelationalPathBase;
import com.mysema.query.types.path.BooleanPath;
import com.mysema.query.types.path.DateTimePath;
import com.mysema.query.types.path.NumberPath;
import com.mysema.query.types.path.StringPath;

import java.sql.Types;
import java.util.Date;

import static com.mysema.query.types.PathMetadataFactory.forVariable;

/**
 * Generated by https://bitbucket.org/atlassian/querydsl-ao-code-gen
 *
 * Changes made by hand:
 *    Map and FK mappings to integers
 *    Map Booleans to BooleanPaths
 *    Map Dates as DateTimePath&lt;Date&gt;
 *
 * Future approach is documented at https://extranet.atlassian.com/x/AAuQj
 */
public class QChangesetMapping extends RelationalPathBase<QChangesetMapping>
{

    private static final long serialVersionUID = 1380247266L;

    public static final String AO_TABLE_NAME = "AO_E8B6CC_CHANGESET_MAPPING";

    public static final QChangesetMapping withSchema(SchemaProvider schemaProvider)
    {
        String schema = schemaProvider.getSchema(AO_TABLE_NAME);
        return new QChangesetMapping("CHANGESET_MAPPING", schema, AO_TABLE_NAME);
    }

    /**
     * Database Columns
     */
    public final StringPath AUTHOR = createString("AUTHOR");

    public final StringPath AUTHOR_EMAIL = createString("AUTHOR_EMAIL");

    public final StringPath BRANCH = createString("BRANCH");

    public final DateTimePath<Date> DATE = createDateTime("DATE", Date.class);

    public final StringPath FILES_DATA = createString("FILES_DATA");

    public final NumberPath<Integer> FILE_COUNT = createNumber("FILE_COUNT", Integer.class);

    public final StringPath FILE_DETAILS_JSON = createString("FILE_DETAILS_JSON");

    public final NumberPath<Integer> ID = createNumber("ID", Integer.class);

    // We have not yet built QueryDSL type support for com.atlassian.jira.plugins.dvcs.activeobjects.v3.IssueToChangesetMapping[] getIssues()


    public final StringPath ISSUE_KEY = createString("ISSUE_KEY");

    public final StringPath MESSAGE = createString("MESSAGE");

    public final StringPath NODE = createString("NODE");

    public final StringPath PARENTS_DATA = createString("PARENTS_DATA");

    public final StringPath PROJECT_KEY = createString("PROJECT_KEY");

    public final StringPath RAW_AUTHOR = createString("RAW_AUTHOR");

    public final StringPath RAW_NODE = createString("RAW_NODE");

    // We have not yet built QueryDSL type support for com.atlassian.jira.plugins.dvcs.activeobjects.v3.RepositoryMapping[] getRepositories()


    public final NumberPath<Integer> REPOSITORY_ID = createNumber("REPOSITORY_ID", Integer.class);

    public final NumberPath<Integer> VERSION = createNumber("VERSION", Integer.class);

    public final BooleanPath SMARTCOMMIT_AVAILABLE = createBoolean("SMARTCOMMIT_AVAILABLE");

    public final com.mysema.query.sql.PrimaryKey<QChangesetMapping> CHANGESETMAPPING_PK = createPrimaryKey(ID);

    public QChangesetMapping(String variable, String schema, String table)
    {
        super(QChangesetMapping.class, forVariable(variable), schema, table);
        addMetadata();
    }

    private void addMetadata()
    {
        /**
         * Database Metadata is not yet used by QueryDSL but it might one day.
         */
        addMetadata(AUTHOR, ColumnMetadata.named("AUTHOR").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(AUTHOR_EMAIL, ColumnMetadata.named("AUTHOR_EMAIL").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(BRANCH, ColumnMetadata.named("BRANCH").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..

        addMetadata(FILES_DATA, ColumnMetadata.named("FILES_DATA").ofType(Types.VARCHAR)); // .withSize(2147483647)); // until detect primitive types, int ..
        addMetadata(FILE_COUNT, ColumnMetadata.named("FILE_COUNT").ofType(Types.INTEGER)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(FILE_DETAILS_JSON, ColumnMetadata.named("FILE_DETAILS_JSON").ofType(Types.VARCHAR)); // .withSize(2147483647)); // until detect primitive types, int ..
        addMetadata(ID, ColumnMetadata.named("ID").ofType(Types.INTEGER)); // .withSize(0).withNotNull()); // until detect primitive types, int ..

        addMetadata(ISSUE_KEY, ColumnMetadata.named("ISSUE_KEY").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(MESSAGE, ColumnMetadata.named("MESSAGE").ofType(Types.VARCHAR)); // .withSize(2147483647)); // until detect primitive types, int ..
        addMetadata(NODE, ColumnMetadata.named("NODE").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(PARENTS_DATA, ColumnMetadata.named("PARENTS_DATA").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(PROJECT_KEY, ColumnMetadata.named("PROJECT_KEY").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(RAW_AUTHOR, ColumnMetadata.named("RAW_AUTHOR").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(RAW_NODE, ColumnMetadata.named("RAW_NODE").ofType(Types.VARCHAR)); // .withSize(0)); // until detect primitive types, int ..

        addMetadata(REPOSITORY_ID, ColumnMetadata.named("REPOSITORY_ID").ofType(Types.INTEGER)); // .withSize(0)); // until detect primitive types, int ..
        addMetadata(VERSION, ColumnMetadata.named("VERSION").ofType(Types.INTEGER)); // .withSize(0)); // until detect primitive types, int ..

        addMetadata(SMARTCOMMIT_AVAILABLE, ColumnMetadata.named("SMARTCOMMIT_AVAILABLE").ofType(Types.BOOLEAN));
        addMetadata(DATE, ColumnMetadata.named("DATE").ofType(Types.TIMESTAMP));
    }
}